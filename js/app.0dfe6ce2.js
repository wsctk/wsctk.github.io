(function(e){function t(t){for(var n,o,i=t[0],s=t[1],r=t[2],v=0,m=[];v<i.length;v++)o=i[v],Object.prototype.hasOwnProperty.call(l,o)&&l[o]&&m.push(l[o][0]),l[o]=0;for(n in s)Object.prototype.hasOwnProperty.call(s,n)&&(e[n]=s[n]);c&&c(t);while(m.length)m.shift()();return p.push.apply(p,r||[]),a()}function a(){for(var e,t=0;t<p.length;t++){for(var a=p[t],n=!0,i=1;i<a.length;i++){var s=a[i];0!==l[s]&&(n=!1)}n&&(p.splice(t--,1),e=o(o.s=a[0]))}return e}var n={},l={app:0},p=[];function o(t){if(n[t])return n[t].exports;var a=n[t]={i:t,l:!1,exports:{}};return e[t].call(a.exports,a,a.exports,o),a.l=!0,a.exports}o.m=e,o.c=n,o.d=function(e,t,a){o.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:a})},o.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},o.t=function(e,t){if(1&t&&(e=o(e)),8&t)return e;if(4&t&&"object"===typeof e&&e&&e.__esModule)return e;var a=Object.create(null);if(o.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)o.d(a,n,function(t){return e[t]}.bind(null,n));return a},o.n=function(e){var t=e&&e.__esModule?function(){return e["default"]}:function(){return e};return o.d(t,"a",t),t},o.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},o.p="/";var i=window["webpackJsonp"]=window["webpackJsonp"]||[],s=i.push.bind(i);i.push=t,i=i.slice();for(var r=0;r<i.length;r++)t(i[r]);var c=s;p.push([0,"chunk-vendors"]),a()})({0:function(e,t,a){e.exports=a("56d7")},"150b":function(e,t,a){},"56d7":function(e,t,a){"use strict";a.r(t);a("e260"),a("e6cf"),a("cca6"),a("a79d");var n=a("2b0e"),l=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",{attrs:{id:"app"}},[a("router-view")],1)},p=[],o={name:"app"},i=o,s=a("2877"),r=Object(s["a"])(i,l,p,!1,null,null,null),c=r.exports,v=(a("b0ee"),a("450d"),a("d180")),m=a.n(v),_=(a("a335"),a("c0bb")),u=a.n(_),d=(a("ce18"),a("f58e")),h=a.n(d),f=(a("34db"),a("3803")),b=a.n(f),g=(a("8bd8"),a("4cb2")),S=a.n(g),y=(a("4ca3"),a("443e")),O=a.n(y),M=(a("a769"),a("5cc3")),x=a.n(M),C=(a("a673"),a("7b31")),j=a.n(C),E=(a("de31"),a("c69e")),T=a.n(E),N=(a("adec"),a("3d2d")),w=a.n(N);n["default"].use(w.a),n["default"].use(T.a),n["default"].use(j.a),n["default"].use(x.a),n["default"].use(O.a),n["default"].use(S.a),n["default"].use(b.a),n["default"].use(h.a),n["default"].use(u.a),n["default"].use(m.a);var k=a("8c4f"),L=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("el-container",{staticClass:"home_container"},[a("el-header",{attrs:{height:"70px"}},[a("div",{staticClass:"header"},[e._v("Welcome to my tool-use-article web!")])]),a("el-container",[a("el-aside",{attrs:{width:"200px"}},[a("el-menu",{attrs:{"background-color":"#39465f","text-color":"#fff","active-text-color":"#409eff","unique-opened":"",router:""}},e._l(e.menuList,(function(t){return a("el-submenu",{key:t.id,attrs:{index:t.id+""}},[a("template",{slot:"title"},[a("i",{staticClass:"el-icon-menu"}),a("span",[e._v(e._s(t.name))])]),e._l(t.children,(function(t){return a("el-menu-item",{key:t.id,attrs:{index:"/"+t.path}},[a("template",{slot:"title"},[a("span",[e._v(e._s(t.name))])])],2)}))],2)})),1)],1),a("el-main",[a("router-view")],1)],1)],1)},D=[],P={data:function(){return{menuList:[{name:"基本数据类型",id:1,children:[{name:"String",id:1,path:"string"},{name:"Number",id:2,path:"number"},{name:"Object",id:3,path:"object"},{name:"Set",id:4,path:"set"},{name:"Map",id:5,path:"map"}]},{name:"静态对象",id:2,children:[{name:"Array",id:1,path:"array"},{name:"Math",id:2,path:"math"},{name:"正则表达式",id:3,path:"reg"},{name:"Dom",id:4,path:"dom"},{name:"Promise",id:5,path:"promise"}]},{name:"摘抄",id:3,children:[{name:"Strict",id:1,path:"strict"},{name:"弹性盒子",id:2,path:"flexbox"},{name:"WEB常用字体",id:3,path:"webfont"},{name:"伪类",id:4,path:"weilei"},{name:"不常用css",id:5,path:"uncommoncss"},{name:"解构赋值",id:6,path:"destruct"},{name:"模板字符串",id:7,path:"templatestring"}]},{name:"面试题",id:4,children:[{name:"H5和Css",id:1,path:"h5css"},{name:"Js",id:2,path:"js"},{name:"Vue",id:3,path:"vue"},{name:"Http",id:4,path:"http"},{name:"其他",id:5,path:"others"}]}]}},mounted:function(){this.$setMainHeight()}},R=P,J=(a("d403"),Object(s["a"])(R,L,D,!1,null,"8e1f8046",null)),A=J.exports,I=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"一般方法",name:"1"}},[a("p",[e._v("连接两个或多个字符串：cancat()")]),a("p",[e._v("返回指定位置的字符串，不改变原字符串：slice(start，end)")]),a("p",[e._v("将字符串显示为小写：toLowerCase()")]),a("p",[e._v("将字符串显示为大写：toUpperCase()")]),a("p",[e._v("将指定字符编码转换成字符串：String.fromCharCode()")]),a("p",[e._v("返回指定长度的字符串，不改变原字符串：substr(start，len)")]),a("p",[e._v("返回一个新字符串，表示将原字符串重复n次：repeat(n)")]),a("p",[e._v("如果某个字符串不够指定长度，会在头部补全：padStart(num, str)")]),a("p",[e._v("如果某个字符串不够指定长度，会在尾部补全：padEnd(num, str)")])]),a("el-collapse-item",{attrs:{title:"字符方法",name:"2"}},[a("p",[e._v("返回指定位置字符：charAt(index)")]),a("p",[e._v("返回指定位置字符的Unicode编码：charCodeAt()")])]),a("el-collapse-item",{attrs:{title:"字符串位置方法",name:"3"}},[a("p",[e._v(" 返回指定字符串在字符串中首次出现的位置：indexOf(字符串，从何处开始) ")]),a("p",[e._v(" 返回指定字符串在字符串中最后出现的位置(从后往前检索)：lastIndexOf(字符串，从何处开始) ")]),a("p",[e._v("返回第一个与指定字符串或正则表达式匹配的位置：search()")]),a("p",[e._v(" 返回布尔值，表示参数字符串是否在原字符串的头部：startsWith(字符串，从何处开始) ")]),a("p",[e._v(" 返回布尔值，表示参数字符串是否在原字符串的尾部：endsWith(字符串，从何处开始) ")])]),a("el-collapse-item",{attrs:{title:"字符串模式匹配方法",name:"4"}},[a("p",[e._v(" 返回布尔值，表示是否找到了参数字符串：includes(字符串，从何处开始) ")]),a("p",[e._v("返回字符串中指定字符串或正则表达式的值：match()")]),a("p",[e._v(" 以遍历器的形式返回字符串中指定字符串或正则表达式的所有匹配：matchAll() ")]),a("p",[e._v(" 返回用指定字符串替代指定字符串或正则表达式指代的字符串后的新字符串：replace() ")]),a("p",[e._v("在指定字符串或正则表达式处分隔整个字符串成字符串数组：split()")])])],1)],1)},H=[],$={methods:{handleChange:function(){}}},U=$,F=Object(s["a"])(U,I,H,!1,null,"27ecce8a",null),V=F.exports,W=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"Number属性",name:"1"}},[a("p",[e._v(" 表示1与Number可表示的大于1的最小的浮点数之间的差值：Number.EPSILON ")]),a("p",[e._v("JavaScript中最大的安全整数：Number.MAX_SAFE_INTEGER")]),a("p",[e._v("能表示的最大正数：Number.MAX_VALUE")]),a("p",[e._v("JavaScript 中最小的安全整数：Number.MIN_SAFE_INTEGER")]),a("p",[e._v(" 能表示的最小正数即最接近 0 的正数(实际上不会变成0)：Number.MIN_VALUE ")]),a("p",[e._v("特殊的'非数字'值：Number.NAN")]),a("p",[e._v("特殊的负无穷大值，在溢出时返回该值：Number.NEGATIVE_INFINITY")]),a("p",[e._v("特殊的正无穷大值，在溢出时返回该值：Number.POSITIVE_INFINITY")])]),a("el-collapse-item",{attrs:{title:"Number方法",name:"2"}},[a("p",[e._v("判断传递的值是否是NaN：Number.isNAN()")]),a("p",[e._v("判断传递的值类型及本身是否是有限数：Number.isFinite()")]),a("p",[e._v("判断传递的值类型是否是'number'，且是否是整数：Number.isInteger()")]),a("p",[e._v("判断传递的值是否为安全整数：Number.isSafeInteger()")]),a("p",[e._v("将字符串转换成浮点数：Number.parseFloat()")]),a("p",[e._v("将字符串转换成整数：Number.parseInt()")])])],1)],1)},q=[],B={methods:{handleChange:function(){}}},G=B,Y=Object(s["a"])(G,W,q,!1,null,"af93d858",null),X=Y.exports,z=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"Object方法",name:"1"}},[a("p",[e._v(" 将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回此对象：Object.assign(target, ...sources) ")]),a("p",[e._v(" 创建一个新对象,使用现有的对象来提供新创建的对象的__proto__：Object.create(proto[, propertiesObject]) ")]),a("p",[e._v(" 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象：Object.defineProperty(obj, prop, descriptor) ")]),a("p",[e._v(" 直接在一个对象上定义新属性，或者修改对象的现有属性，并返回此对象：Object.defineProperties(obj, props) ")]),a("p",[e._v("返回给定对象自身可枚举属性的[key, value]数组：Object.entries(obj)")]),a("p",[e._v("返回给定对象自身可枚举值的数组：Object.values(obj)")]),a("p",[e._v("返回给定对象自身可枚举属性名称的数组:Object.keys(obj)")]),a("p",[e._v("冻结对象：其他代码不能删除或更改任何属性：Object.freeze(obj)")]),a("p",[e._v(" 封闭一个对象，使其不能添加新属性而且不能删除现有属性，但是可以修改属性值：Object.seal(obj) ")]),a("p",[e._v("防止对象的任何扩展：Object.preventExtensions(obj)")]),a("p",[e._v(" 返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名：Object.getOwnPropertyNames(obj) ")]),a("p",[e._v(" 返回一个给定对象自身的所有 Symbol 属性的数组：Object.getOwnPropertySymbols(obj) ")]),a("p",[e._v(" 返回指定对象上一个自有属性对应的属性描述符：Object.getOwnPropertyDescriptor(obj, prop) ")]),a("p",[e._v("返回指定对象的原型对象：Object.getPrototypeOf(obj)")]),a("p",[e._v("设置对象的原型：Object.setPrototypeOf(obj, prototype)")]),a("p",[e._v("判断两个值是否是相同的值：Object.is(value1, value2)")]),a("p",[e._v("判断对象是否可扩展：Object.isExtensible(obj)")]),a("p",[e._v("判断对象是否已经冻结：Object.isFrozen(obj)")]),a("p",[e._v("判断对象是否已经密封：Object.isSealed()")])])],1)],1)},K=[],Q={methods:{handleChange:function(){}}},Z=Q,ee=Object(s["a"])(Z,z,K,!1,null,"c145c570",null),te=ee.exports,ae=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"Set操作方法",name:"1"}},[a("p",[e._v("在Set对象尾部添加一个元素。返回该Set对象：mySet.add(value);")]),a("p",[e._v(" 从一个 Set 对象中删除指定的元素，成功删除返回true，否则返回false：mySet.delete(value); ")]),a("p",[e._v(" 返回一个布尔值来指示对应的值value是否存在Set对象中：mySet.has(value); ")]),a("p",[e._v("用来清空一个Set对象中的所有元素：mySet.clear();")])]),a("el-collapse-item",{attrs:{title:"Set遍历方法",name:"2"}},[a("p",[e._v(" 返回一个元素类似[value,value]数组形式的迭代器对象，其中value是set集合对象中的每个元素：mySet.entries(); ")]),a("p",[e._v(" 返回一个按照原set对象中元素插入顺序返回其所有元素的迭代器对象：mySet.values()/mySet.keys(); ")]),a("p",[e._v(" 根据集合中元素的插入顺序，依次执行提供的回调函数：mySet.forEach(callback[, thisArg]); ")])])],1)],1)},ne=[],le={methods:{handleChange:function(){}}},pe=le,oe=Object(s["a"])(pe,ae,ne,!1,null,"4a94772f",null),ie=oe.exports,se=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"Map操作方法",name:"1"}},[a("p",[e._v(" 为Map对象添加或更新一个指定了键(key)和值(value)的(新)键值对：myMap.set(key, value); ")]),a("p",[e._v("返回某个Map对象中的一个指定元素：myMap.get(key);")]),a("p",[e._v(" 从一个Map对象中删除指定的元素，成功删除返回true，否则返回false：myMap.delete(key); ")]),a("p",[e._v("返回一个布尔值来指示对应的键是否存在Map对象中：myMap.has(key);")]),a("p",[e._v("用来清空一个Map对象中的所有元素：myMap.clear();")])]),a("el-collapse-item",{attrs:{title:"Map遍历方法",name:"2"}},[a("p",[e._v(" 返回一个包含[key,value]对的迭代器对象，其迭代顺序与Map对象的插入顺序相同：myMap.entries(); ")]),a("p",[e._v(" 返回一个按照原Map对象中元素插入顺序返回其每个元素的key值的迭代器对象：myMap.keys(); ")]),a("p",[e._v(" 返回一个按照原Map对象中元素插入顺序返回其每个元素的value值迭代器对象：myMap.values(); ")]),a("p",[e._v(" 根据集合中元素的插入顺序，对Map对象中的每个键值对执行提供的回调函数：myMap.forEach(callback[, thisArg]); ")])])],1)],1)},re=[],ce={methods:{handleChange:function(){}}},ve=ce,me=Object(s["a"])(ve,se,re,!1,null,"03254bf3",null),_e=me.exports,ue=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"栈方法",name:"1"}},[a("p",[e._v("删除并返回数组的最后一个元素：pop()")]),a("p",[e._v("向数组末尾添加一个或多个元素，返回新的长度：push()")])]),a("el-collapse-item",{attrs:{title:"队列方法",name:"2"}},[a("p",[e._v("向数组开头删除一个或多个元素返回被删掉的元素，shift()")]),a("p",[e._v("向数组开头添加一个或多个元素，返回新的长度：unshift()")])]),a("el-collapse-item",{attrs:{title:"操作方法",name:"3"}},[a("p",[e._v("连接两个或更多的数组，返回生成新数组的副本：cancat()")]),a("p",[e._v("把数组所有元素放入一个字符串，通过指定分隔符分隔：join(分隔符)")]),a("p",[e._v("从数组中返回选定的元素，不改变原数组：slice(start，end)(左闭右开)")]),a("p",[e._v(" 删除数组指定位置开始的指定数量元素，并可同时添加指定元素，改变原数组：splice(start，number，items….) ")]),a("p",[e._v(" 将类似数组的对象和可遍历的对象转换为真正的数组：Array.from(array, function) ")]),a("p",[e._v("将一组值转换为数组：Array.of(x,y,...)")]),a("p",[e._v(" 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组：copyWithin(target, start=0, end=this.length) ")]),a("p",[e._v("返回使用指定值填充的数组：fill(x, start, end)")]),a("p",[e._v("返回将嵌套的数组拉平成一维数组的新数组：flat(需要往下拉平的层数)")])]),a("el-collapse-item",{attrs:{title:"重排序方法",name:"4"}},[a("p",[e._v("对数组元素进行基于字符编码的排序：sort(可添加排序函数)")]),a("p",[e._v("颠倒数组元素的顺序：reverse()")])]),a("el-collapse-item",{attrs:{title:"迭代方法",name:"5"}},[a("p",[e._v("检测数组中所有元素是否满足给定条件：every(条件函数)")]),a("p",[e._v("检测数组中是否有元素满足条件：some(条件函数)")]),a("p",[e._v("返回原数组中所有满足给定条件的元素组成的新数组：filter(条件函数)")]),a("p",[e._v("返回数组中满足条件的第一个元素：find(条件函数)")]),a("p",[e._v("返回数组中满足条件的第一个元素的index：findIndex(条件函数)")]),a("p",[e._v("返回经过条件处理后的新数组：map(条件函数)")]),a("p",[e._v("返回一个遍历所有键名的遍历器：keys()")]),a("p",[e._v("返回一个遍历所有键值的遍历器：values()")]),a("p",[e._v("返回一个遍历所有键值对的遍历器：entries()")]),a("p",[e._v("检测数组中是否包含给定的值：includes()")])])],1)],1)},de=[],he={methods:{handleChange:function(){}}},fe=he,be=Object(s["a"])(fe,ue,de,!1,null,"8985a5d6",null),ge=be.exports,Se=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"Math对象属性",name:"1"}},[a("p",[e._v("欧拉常数，也是自然对数的底数，约等于2.718：Math.E")]),a("p",[e._v("2的自然对数，约等于0.693：Math.LN2")]),a("p",[e._v("10的自然对数，约等于2.303：Math.LN10")]),a("p",[e._v("以2为底的E的对数，约等于1.443：Math.LOG2E")]),a("p",[e._v("以10为底的E的对数，约等于0.434：Math.LOG10E")]),a("p",[e._v("圆周率：Math.PI")]),a("p",[e._v("二分之一的平方根，约等于0.707：Math.SQRT1_2")]),a("p",[e._v("2 的平方根：Math.SQRT2")])]),a("el-collapse-item",{attrs:{title:"Math对象方法",name:"2"}},[a("p",[e._v("返回一个数的绝对值：Math.abs(x)")]),a("p",[e._v("返回一个数的立方根：Math.cbrt(x)")]),a("p",[e._v("返回大于一个数的最小整数，即一个数向上取整后的值：Math.ceil(x)")]),a("p",[e._v("返回小于一个数的最大整数，即一个数向下取整后的值：Math.floor(x)")]),a("p",[e._v("返回四舍五入后的整数：Math.round(x)")]),a("p",[e._v("返回一个数的整数部分，直接去除其小数点及之后的部分：Math.trunc(x)")]),a("p",[e._v("返回欧拉常数e的参数次方：Math.exp(x)")]),a("p",[e._v("返回一个数的y次幂：Math.pow(x,y)")]),a("p",[e._v("返回最接近一个数的单精度浮点型表示：Math.fround(x)")]),a("p",[e._v("返回其所有参数平方和的平方根：Math.hypot(x,y,...)")]),a("p",[e._v("返回一个数的自然对数：Math.log(x)")]),a("p",[e._v("返回一个数以10为底数的对数：Math.log10(x)")]),a("p",[e._v("返回一个数以2为底数的对数：Math.log2(x)")]),a("p",[e._v("返回零到多个数值中最大值：Math.max(x,y,...)")]),a("p",[e._v("返回零到多个数值中最小值：Math.min(x,y,...)")]),a("p",[e._v("返回一个0到1之间的伪随机数：Math.random()")]),a("p",[e._v("返回一个数的符号，判断是正数、负数还是0：Math.sign(x)")]),a("p",[e._v("返回一个数的平方根：Math.sqrt(x)")])])],1)],1)},ye=[],Oe={methods:{handleChange:function(){}}},Me=Oe,xe=Object(s["a"])(Me,Se,ye,!1,null,"4462ef88",null),Ce=xe.exports,je=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"正则表达式方法",name:"1"}},[a("p",[e._v("改变和重新编译正则表达式：compile()")]),a("p",[e._v("返回检索到的正则表达式内容：RegExc.exec(String)")]),a("p",[e._v("检测字符串是否包含正则表达式的内容：RegExc.test(String)")])]),a("el-collapse-item",{attrs:{title:"修饰符",name:"2"}},[a("p",[e._v("不分大小写：i")]),a("p",[e._v("查找所有匹配：g")]),a("p",[e._v("查找所有匹配,匹配必须从剩余的第一个位置开始：y")]),a("p",[e._v("使'.'可以匹配任意单个字符：s")])]),a("el-collapse-item",{attrs:{title:"方括号",name:"3"}},[a("p",[e._v("查找指定范围的字符：[abc]")]),a("p",[e._v("查找不在范围内的字符：[^abc]")])]),a("el-collapse-item",{attrs:{title:"元字符",name:"4"}},[a("p",[e._v("除了换行和行结束符的任一字符：.")]),a("p",[e._v("单词(数字，字母，下划线)字符：\\w")]),a("p",[e._v("非单词字符：\\W")]),a("p",[e._v("数字字符：\\d")]),a("p",[e._v("非数字字符：\\D")]),a("p",[e._v("空白字符：\\s")]),a("p",[e._v("非空白字符：\\S")]),a("p",[e._v("匹配单词边界：\\b")]),a("p",[e._v("匹配非单词边界：\\B")]),a("p",[e._v("查找NUL(null)字符：\\0")]),a("p",[e._v("换页符：\\f")]),a("p",[e._v("回车符：\\r")]),a("p",[e._v("制表符：\\t")]),a("p",[e._v("垂直制表符：\\v")]),a("p",[e._v("八进制规定的字符：\\xxx")]),a("p",[e._v("十六进制规定的字符：\\xdd")])]),a("el-collapse-item",{attrs:{title:"量词",name:"5"}},[a("p",[e._v("匹配包含至少一个n的字符串：n+")]),a("p",[e._v("匹配包含任意个n的字符串：n*")]),a("p",[e._v("匹配包含至多一个n的字符串：n?")]),a("p",[e._v("匹配包含x个n的序列的字符串：n{x}")]),a("p",[e._v("匹配包含x到y个n的序列的字符串：n{x，y}")]),a("p",[e._v("匹配包含至少x个n的序列的字符串：n{x，}")]),a("p",[e._v("匹配任何以n结尾的字符串：n$")]),a("p",[e._v("匹配任何以n开头的字符串：^n")]),a("p",[e._v("匹配其后紧接字符串n的字符串：RegExc(?=n)")]),a("p",[e._v("匹配其后没有紧接字符串n的字符串：RegExc(?!=n)")])])],1)],1)},Ee=[],Te={methods:{handleChange:function(){}}},Ne=Te,we=Object(s["a"])(Ne,je,Ee,!1,null,"57ba6ae5",null),ke=we.exports,Le=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"Document对象属性/方法",name:"1"}},[a("p",[e._v("返回当前获得焦点的元素：document.activeElement")]),a("p",[e._v(" 向文档添加事件：document.addEventListener(event，function，useCapture) ")]),a("p",[e._v(" 移除由addEventListener添加的事件：document.removeEventListener(event，function，useCapture) ")]),a("p",[e._v("返回当前文档所有的锚点：document.anchors[]")]),a("p",[e._v("返回当前文档所有的form对象：document.forms[]")]),a("p",[e._v("返回当前文档所有的image对象：document.images[]")]),a("p",[e._v("返回当前文档所有的链接的数组：document.links[]")]),a("p",[e._v("向文档写HTML表达式或JavaScript代码：document.write()")]),a("p",[e._v(" 向文档写HTML表达式或JavaScript代码，并在每个表达式后写一个换行符：document.writeIn() ")]),a("p",[e._v(" 打开一个输出流来收集document.write()或document.writeIn()输出的内容：document.open(MIMEtype，replace) ")]),a("p",[e._v(" 关闭由document.open打开的输出流，并显示选定的数据：document.close() ")]),a("p",[e._v("设置或返回与当前文档有关的所有cookie：document.cookie")]),a("p",[e._v(" 创建一个指定名称的属性并返回该属性：document.createAttribute(attributename) ")]),a("p",[e._v("创建注释节点：document.createComment(text)")]),a("p",[e._v(" 创建并返回一个附有所有新节点的文档碎片：document.createDocumentFragment() ")]),a("p",[e._v("创建并返回一个元素：document.createElement()")]),a("p",[e._v("创建并返回一个文本节点：document.createTextNode()")]),a("p",[e._v(" 返回所有指定类名的元素的集合：document.getElementsByClassName(classname) ")]),a("p",[e._v("返回拥有指定id的第一个对象：document.getElementById()")]),a("p",[e._v("返回带有指定名称的所有对象的集合：document.getElementsByName()")]),a("p",[e._v(" 返回带有指定标签名的所有对象的集合：document.getElementsByTagName() ")]),a("p",[e._v(" 返回文档中匹配指定CSS选择器的第一个元素：document.querySelector(Css selector) ")]),a("p",[e._v(" 返回文档中匹配指定CSS选择器的所有元素节点列表：document.querySelectorAll(Css selector) ")]),a("p",[e._v("返回处理该文档的DOMImplementation对象：document.implementation；")]),a("p",[e._v("从另一个文档复制一个节点到当前文档：document.importNode()")]),a("p",[e._v("合并相邻的文本节点并删除空的文本节点：document.normalize()")])]),a("el-collapse-item",{attrs:{title:"HTML元素属性\\方法",name:"2"}},[a("p",[e._v("设置或返回单选按钮快捷键：element.accessKey=accesskey")]),a("p",[e._v("设置或返回元素的类名：element.className")]),a("p",[e._v("设置或返回元素的id：element.id")]),a("p",[e._v("设置或返回元素的内容：element.innerHTML")]),a("p",[e._v("设置或返回元素的内容是否可编辑：element.contentEditable")]),a("p",[e._v("设置或返回元素的文字方向：element.dir=text.direction")]),a("p",[e._v("以字符串形式返回一个元素的标签名：element.tagName")]),a("p",[e._v("设置或返回指定元素的文本内容：element.textContent")]),a("p",[e._v("设置或返回元素的title属性值：element.title")]),a("p",[e._v("返回节点集合的数目：element.length")]),a("p",[e._v(" 向指定元素添加事件：element.addEventListener(event，function，useCapture) ")]),a("p",[e._v(" 移除指定元素的事件：element.removeEventListener(event，function，useCapture) ")]),a("p",[e._v(" 向指定节点的子节点的列表末尾添加新的节点：element.appendChild(node) ")]),a("p",[e._v("返回元素所有属性的集合：element.attributes[]")]),a("p",[e._v("返回一个元素子节点的数组：element.childNodes[]")]),a("p",[e._v("返回元素的第一个子节点：element.firstChild")]),a("p",[e._v("返回元素的最后一个子节点：element.lastChild")]),a("p",[e._v("返回元素其后紧跟的元素：element.nextSibling")]),a("p",[e._v("返回元素紧接之前的元素：element.previousSibling")]),a("p",[e._v("依据元素类型返回其名称：element.nodeName")]),a("p",[e._v("依据元素类型返回节点类型，用数字表示：element.nodeType")]),a("p",[e._v("设置或返回节点的值：element.nodeValue")]),a("p",[e._v("设置或返回元素的样式属性：element.style")]),a("p",[e._v("为元素设置焦点：element.focus()")]),a("p",[e._v("返回指定元素的属性值：element.getAttribute()")]),a("p",[e._v("设置指定元素的属性值：element.setAttribute()")]),a("p",[e._v("返回指定元素的属性节点：element.getAttributeNode()")]),a("p",[e._v("设置指定元素的属性节点：element.setAttributeNode()")]),a("p",[e._v(" 返回指定标签名元素的所有子元素集合：element.getElementsByTagName() ")]),a("p",[e._v(" 返回指定类名的元素的所有子元素集合：element.getElementsByClassName() ")]),a("p",[e._v("返回元素是否含有某个属性：element.hasAttribute()")]),a("p",[e._v("返回元素是否含有任何属性：element.hasAttributes()")]),a("p",[e._v("返回文档或元素是否获取焦点：element.hasfocus()")]),a("p",[e._v("返回一个元素是否含有任何子元素：element.hasChildNodes()")]),a("p",[e._v("返回两个元素是否相等：element.isEqualNode(node)")]),a("p",[e._v("返回两个元素是否是同一个节点：element.isSameNode(node)")]),a("p",[e._v(" 返回当前节点是否支持某个特性：element.issupported(feature，version) ")]),a("p",[e._v("创建指定节点的拷贝：element.cloneNode()")]),a("p",[e._v(" 比较当前节点和指定节点的文档位置：element.compareDocumentPosition(node) ")]),a("p",[e._v(" 在指定子元素前插入一个新的子元素：element.insertBefore(newnode，existingnode) ")]),a("p",[e._v("合并元素内相邻的文本节点并删除空的文本节点：element.normalize()")]),a("p",[e._v("返回元素的父节点：element.parentNode")]),a("p",[e._v("返回元素中匹配指定CSS选择器的第一个元素：element.querySelector()")]),a("p",[e._v("删除子节点列表中的某个节点：element.removeChild()")]),a("p",[e._v("调换某个子元素：element.replaceChild()")])]),a("el-collapse-item",{attrs:{title:"返回元素的类名，作为DOMTokenlist：element.classList对象",name:"3"}},[a("p",[e._v("在元素中添加一个或多个类名：element.classList.add(class1……)")]),a("p",[e._v("判断指定类名是否存在：element.classList.contain(class)")]),a("p",[e._v("返回指定索引值的类名：element.classList.item(index)")]),a("p",[e._v("移除元素中一个或多个类名：element. classList.remove(class1……)")]),a("p",[e._v("在元素中切换类名：element.classList.toggle(class，true|false)")])]),a("el-collapse-item",{attrs:{title:"Dom属性对象方法",name:"4"}},[a("p",[e._v("返回属性是否是ID类型：attr.isId")]),a("p",[e._v("返回属性名称：attr.name")]),a("p",[e._v("设置或返回属性值：attr.value")]),a("p",[e._v("返回属性值是否被设定：attr.specified")]),a("p",[e._v("返回属性节点列表中指定属性名的值：attr.getNamedItem(name)")]),a("p",[e._v("返回属性节点列表中指定索引号的节点：attr.item(index)")]),a("p",[e._v("删除指定的节点：attr.removeNamedItem(name)")]),a("p",[e._v("添加指定节点：attr.setNameditem(name)")])]),a("el-collapse-item",{attrs:{title:"Dom事件属性-鼠标事件",name:"5"}},[a("p",[e._v("单击：onclick")]),a("p",[e._v("右击：oncontextmenu")]),a("p",[e._v("双击：ondblclick")]),a("p",[e._v("按下：onmousedown")]),a("p",[e._v("松开：onmouseup")]),a("p",[e._v("指针移动到元素上：onmouseenter")]),a("p",[e._v("指针移出元素：onmouseleave")]),a("p",[e._v("指针移动：onmousemove")]),a("p",[e._v("指针在元素上：onmouseover")]),a("p",[e._v("指针不在元素上：onmouseout")])]),a("el-collapse-item",{attrs:{title:"Dom事件属性-键盘事件",name:"6"}},[a("p",[e._v("按下：onkeydown")]),a("p",[e._v("松开：onkeyup")]),a("p",[e._v("按下并松开：onkeypress")])]),a("el-collapse-item",{attrs:{title:"Dom事件属性-框架/对象事件",name:"7"}},[a("p",[e._v("即将离开页面：onbeforeunload")]),a("p",[e._v("离开页面：onunload")]),a("p",[e._v("加载文档或图像时发生错误：onerror")]),a("p",[e._v("URL的锚部分发生改变：onhashchange")]),a("p",[e._v("文档或图像完成加载：onload")]),a("p",[e._v("页面被浏览：onpageshow")]),a("p",[e._v("离开当前页面：onpagehide")]),a("p",[e._v("窗口或框架被调整大小：onresize")]),a("p",[e._v("滚动滚动条：onscroll")])]),a("el-collapse-item",{attrs:{title:"Dom事件属性-表单事件",name:"8"}},[a("p",[e._v("元素即将失去焦点：onfocusout")]),a("p",[e._v("元素失去焦点：onblur")]),a("p",[e._v("元素即将获得焦点：onfocusin")]),a("p",[e._v("元素获得焦点：onfocus")]),a("p",[e._v("表单元素内容发生改变：onchange")]),a("p",[e._v("表单元素获取到输入：oninput")]),a("p",[e._v("重置：onreset")]),a("p",[e._v("向搜索域输入文本：onsearch")]),a("p",[e._v("选中文本框中的文本：onselect")]),a("p",[e._v("提交：onsubmit")])]),a("el-collapse-item",{attrs:{title:"Dom事件属性-剪贴板事件",name:"9"}},[a("p",[e._v("拷贝元素内容：oncopy")]),a("p",[e._v("剪切元素内容：oncut")]),a("p",[e._v("粘贴元素内容：onpaste")]),a("p",[e._v("开始打印或打印框已经关闭：onafterprint")]),a("p",[e._v("即将打印：onbeforeprint")])]),a("el-collapse-item",{attrs:{title:"Dom事件属性-拖动事件",name:"10"}},[a("p",[e._v("元素正被拖动：ondrag")]),a("p",[e._v("开始拖动：ondragstart")]),a("p",[e._v("拖动完成：ondragend")]),a("p",[e._v("拖动元素进入有效放置区域：ondragenter")]),a("p",[e._v("拖动元素离开有效放置区域：ondragleave")]),a("p",[e._v("拖动元素在有效放置区域上：ondragover")])]),a("el-collapse-item",{attrs:{title:"Dom事件属性-多媒体事件",name:"11"}},[a("p",[e._v("开始寻找视频/音频：onloadstart")]),a("p",[e._v("视频/音频的时长发生变化：ondurationchange")]),a("p",[e._v("指定视频/音频的元数据加载：onloadedmetadata")]),a("p",[e._v("加载完成当前帧：onloadeddata")]),a("p",[e._v("下载指定的视频/音频：onprogress")]),a("p",[e._v("可以开始播放视频/音频：oncanplay")]),a("p",[e._v("可以无需停顿或缓冲开始播放视频/音频：oncanplaythrough")]),a("p",[e._v("视频/音频中止加载：onabort")]),a("p",[e._v("视频/音频加载发生错误：onerror")]),a("p",[e._v("视频/音频播放结束：onended")]),a("p",[e._v("视频/音频暂停：onpause")]),a("p",[e._v("视频/音频开始播放：onplay")]),a("p",[e._v("视频/音频暂停或在缓冲后重新开始播放：onplaying")]),a("p",[e._v("视频/音频播放速度发生变化：onratechange")]),a("p",[e._v("开始定位播放进度：onseeking")]),a("p",[e._v("重新定位播放进度完成：onseeked")]),a("p",[e._v("获取媒体数据，但媒体数据不可用：onstalled")]),a("p",[e._v("读取媒体数据中止：onsuspend")]),a("p",[e._v("当前播放进度发生改变：ontimeupdate")]),a("p",[e._v("音量发生改变：onvolumechange")]),a("p",[e._v("视频播放下一帧需要缓冲：onwaiting")])]),a("el-collapse-item",{attrs:{title:"Dom事件属性-动画/过渡事件",name:"12"}},[a("p",[e._v("css动画开始播放：animationstart")]),a("p",[e._v("css动画结束播放：animationend")]),a("p",[e._v("css动画重复播放：animationiteration")]),a("p",[e._v("css过渡完成：transitionend")])])],1)],1)},De=[],Pe={methods:{handleChange:function(){}}},Re=Pe,Je=Object(s["a"])(Re,Le,De,!1,null,"ddb09fd4",null),Ae=Je.exports,Ie=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"Promise方法",name:"1"}},[a("p",[e._v(" 用于将多个 Promise 实例，包装成一个新的Promise实例：Promise.all(iterable) ")]),a("p",[e._v(" 用于指定不管 Promise 对象最后状态如何，都会执行的操作：p.finally(onFinally) ")]),a("p",[e._v("用于指定promise发生错误时的回调函数：p.catch(onRejected)")]),a("p",[e._v(" 为Promise实例添加状态改变时的回调函数：p.then(onFulfilled[, onRejected]) ")]),a("p",[e._v(" 返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝：Promise.race(iterable) ")]),a("p",[e._v(" 返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果：Promise.allSettled(iterable) ")]),a("p",[e._v("返回一个以给定值解析后的Promise对象：Promise.resolve(value)")]),a("p",[e._v("返回一个带有拒绝原因的Promise对象：Promise.reject(reason)")])])],1)],1)},He=[],$e={methods:{handleChange:function(){}}},Ue=$e,Fe=Object(s["a"])(Ue,Ie,He,!1,null,"19039012",null),Ve=Fe.exports,We=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"严格模式",name:"1"}},[a("p",[e._v("变量必须声明后再使用")]),a("p",[e._v("函数的参数不能有同名属性，否则报错")]),a("p",[e._v("不能使用with语句")]),a("p",[e._v("不能对只读属性赋值，否则报错")]),a("p",[e._v("不能使用前缀 0 表示八进制数，否则报错")]),a("p",[e._v("不能删除不可删除的属性，否则报错")]),a("p",[e._v("不能删除变量delete prop，会报错，只能删除属性delete global[prop]")]),a("p",[e._v("eval不会在它的外层作用域引入变量")]),a("p",[e._v("eval和arguments不能被重新赋值")]),a("p",[e._v("arguments不会自动反映函数参数的变化")]),a("p",[e._v("不能使用arguments.callee")]),a("p",[e._v("不能使用arguments.caller")]),a("p",[e._v("禁止this指向全局对象")]),a("p",[e._v("不能使用fn.caller和fn.arguments获取函数调用的堆栈")]),a("p",[e._v("增加了保留字（比如protected、static和interface）")])])],1)],1)},qe=[],Be={methods:{handleChange:function(){}}},Ge=Be,Ye=Object(s["a"])(Ge,We,qe,!1,null,"4e523780",null),Xe=Ye.exports,ze=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"display: flex | inline-flex",name:"1"}},[a("p",[e._v("flex：将对象作为弹性盒显示")]),a("p",[e._v("inline-flex：将对象作为内联块级弹性盒显示")])]),a("el-collapse-item",{attrs:{title:"flex-direction：设置伸缩盒主轴的起点和终点位置",name:"2"}},[a("p",[e._v("row：默认位置，主轴横向，起点在左侧")]),a("p",[e._v("row-reverse：主轴横向反转，起点在右侧")]),a("p",[e._v("column：主轴纵向，起点在上方")]),a("p",[e._v("column-reverse：主轴纵向，起点在下方")])]),a("el-collapse-item",{attrs:{title:"justify-content：设置元素在主轴方向上的排列方式",name:"3"}},[a("p",[e._v("flex-start：元素向行起始位置对齐排列")]),a("p",[e._v("flex-end：元素向行结束位置对齐排列")]),a("p",[e._v("center：元素向行中间位置对齐排列")]),a("p",[e._v("space-between：元素会平均地分布在行里")]),a("p",[e._v(" space-around：元素会平均地分布在行里，两端保留元素之间间距大小的一半 ")])]),a("el-collapse-item",{attrs:{title:"align-items：设置元素在侧轴方向上的排列方式",name:"4"}},[a("p",[e._v("flex-start：元素紧靠该行的侧轴起始边界")]),a("p",[e._v("flex-end：元素紧靠该行的侧轴结束边界")]),a("p",[e._v("center：元素在该行的侧轴上居中放置")]),a("p",[e._v("baseline：元素与基线对齐")]),a("p",[e._v("stretch：如果元素未设置宽高，将元素在侧轴方向上拉伸为与父元素相同")])]),a("el-collapse-item",{attrs:{title:"align-self：设置元素自身在侧轴方向上的对齐方式",name:"5"}},[a("p",[e._v("auto：与父元素的align-items相同")]),a("p",[e._v("flex-start：元素紧靠该行的侧轴起始边界")]),a("p",[e._v("flex-end：元素紧靠该行的侧轴结束边界")]),a("p",[e._v("center：元素在该行的侧轴上居中放置")]),a("p",[e._v("baseline：元素与基线对齐")]),a("p",[e._v("stretch：如果元素未设置宽高，将元素在侧轴方向上拉伸为与父元素相同")])]),a("el-collapse-item",{attrs:{title:"align-content：设置换行后行的排列方式",name:"6"}},[a("p",[e._v("flex-start：各行向容器的起始位置堆叠")]),a("p",[e._v("flex-end：各行向容器的结束位置堆叠")]),a("p",[e._v("center：各行向容器的中间位置堆叠")]),a("p",[e._v("space-between：各行在容器中平均分布")]),a("p",[e._v("space-around：各行在容器中平均分布，两端保留行间距大小的一半")]),a("p",[e._v("stretch：各行伸展以占用剩余的空间")])]),a("el-collapse-item",{attrs:{title:"flex-wrap：设置子元素超出父容器时是否换行",name:"7"}},[a("p",[e._v("nowrap：不换行")]),a("p",[e._v("wrap：往下换行")]),a("p",[e._v("wrap-reverse：往上换行")])]),a("el-collapse-item",{attrs:{title:"flex-grow：设置元素的扩展比例",name:"8"}}),a("el-collapse-item",{attrs:{title:"flex-shirnk：设置元素的收缩比例",name:"9"}}),a("el-collapse-item",{attrs:{title:"flex-basis：设置元素的基准宽度",name:"10"}})],1)],1)},Ke=[],Qe={methods:{handleChange:function(){}}},Ze=Qe,et=Object(s["a"])(Ze,ze,Ke,!1,null,"53e2a11d",null),tt=et.exports,at=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"web常用中文字体及其英文名",name:"1"}},[a("p",[e._v("宋体：SimSun")]),a("p",[e._v("黑体：SimHei")]),a("p",[e._v("微软雅黑：Microsoft Yahei")]),a("p",[e._v("微软正黑体：Microsoft Jhenghei")]),a("p",[e._v("楷体：KaiTi")]),a("p",[e._v("新宋体：NSImSun")]),a("p",[e._v("仿宋：FangSong")])]),a("el-collapse-item",{attrs:{title:"OS X 系统内置中文字体",name:"2"}},[a("p",[e._v("宋体：SimSun")]),a("p",[e._v("黑体：SimHei")]),a("p",[e._v("微软雅黑：Microsoft Yahei")]),a("p",[e._v("微软正黑体：Microsoft Jhenghei")]),a("p",[e._v("楷体：KaiTi")]),a("p",[e._v("新宋体：NSImSun")]),a("p",[e._v("仿宋：FangSong")])]),a("el-collapse-item",{attrs:{title:"其他一些中文字体",name:"3"}},[a("p",[e._v("幼圆：YouYuan")]),a("p",[e._v("隶书：LiSu")]),a("p",[e._v("华文细黑：STXihei")]),a("p",[e._v("华文彩云：STCaiyun")]),a("p",[e._v("方正舒体：FZShuTi")]),a("p",[e._v("方正姚体：FZYaoti")]),a("p",[e._v("思源黑体：Source Han Sans CN")]),a("p",[e._v("思源宋体：Source Han Serif SC")]),a("p",[e._v("文泉驿微米黑：WenQuanYi Micro Hei")])])],1)],1)},nt=[],lt={methods:{handleChange:function(){}}},pt=lt,ot=Object(s["a"])(pt,at,nt,!1,null,"adc3a096",null),it=ot.exports,st=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"Css不常用伪类选择器",name:"1"}},[a("p",[e._v(":empty：选择没有子元素的目标元素")]),a("p",[e._v(":enabled：选择所有已启用的目标元素")]),a("p",[e._v(":disabled：选择所有已禁用的目标元素")]),a("p",[e._v(":checked：选择所有已选中的目标元素")]),a("p",[e._v(":not(selector)：选择每个不是selector元素的元素")]),a("p",[e._v("::selection：匹配元素中被用户选中或处于高亮状态的部分")]),a("p",[e._v(":out-of-range：匹配值在指定区间之外的input元素")]),a("p",[e._v(":in-range：匹配值在指定区间内的input元素")]),a("p",[e._v(":read-write：匹配可读及可写的元素")]),a("p",[e._v(":read-only：匹配设置只读属性的元素")]),a("p",[e._v(":required：匹配必选的元素")]),a("p",[e._v(":optional：匹配可选(非必选)的输入元素")]),a("p",[e._v(":valid：匹配输入值为合法的元素")]),a("p",[e._v(":invalid：匹配输入值为非法的元素")])]),a("el-collapse-item",{attrs:{title:"后代选择器",name:"2"}},[a("p",[e._v("el1>el2：选择所有父级为el1元素的el2元素")]),a("p",[e._v("el1+el2：选择所有紧接在el1元素之后的el2元素")]),a("p",[e._v("el1~el2：选择el1元素之后的所有el2元素")])]),a("el-collapse-item",{attrs:{title:"属性选择器",name:"3"}},[a("p",[e._v("[attr]：选择所有带attr属性的元素")]),a("p",[e._v("[attr=value]：选择所有attr属性值为value的元素")]),a("p",[e._v("[attr~=value]：选择所有attr属性值中包含value的元素")]),a("p",[e._v(" [attr|=value]：选择所有attr属性值以value开头的元素(后续字符要以-连接) ")]),a("p",[e._v("[attr^=value]：选择所有attr属性值以value开头的元素")]),a("p",[e._v("[attr$=value]：选择所有attr属性值以value结尾的元素")]),a("p",[e._v("[attr*=value]：选择所有attr属性值包含子字符串value的元素")])])],1)],1)},rt=[],ct={methods:{handleChange:function(){}}},vt=ct,mt=Object(s["a"])(vt,st,rt,!1,null,"e97e02f2",null),_t=mt.exports,ut=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"line-clamp",name:"1"}},[a("p",[e._v(' 可以把块容器中的内容限制为指定的行数。并且在超过行数后，在最后一行显示"..." ')])]),a("el-collapse-item",{attrs:{title:"caret-color",name:"2"}},[a("p",[e._v("用来定义插入光标（caret）的颜色")])]),a("el-collapse-item",{attrs:{title:"shape-outside",name:"3"}},[a("p",[e._v(" 定义了一个可以是非矩形的形状，相邻的内联内容应围绕该形状进行包装。 默认情况下，内联内容包围其边距框; shape-outside提供了一种自定义此包装的方法，可以将文本包装在复杂对象周围而不是简单的框中 ")])]),a("el-collapse-item",{attrs:{title:"object-fit",name:"4"}},[a("p",[e._v("指定可替换元素的内容应该如何适应到其使用的高度和宽度确定的框")])]),a("el-collapse-item",{attrs:{title:"object-position",name:"5"}},[a("p",[e._v("指定被替换元素的内容对象在元素框内的位置")])]),a("el-collapse-item",{attrs:{title:"resize",name:"6"}},[a("p",[e._v("规定可以由用户调整div元素的大小(需要设置overflow)")])]),a("el-collapse-item",{attrs:{title:"scroll-behavior",name:"7"}},[a("p",[e._v(" 当用户手动导航或者触发滚动操作时，scroll-behavior为一个滚动框指定滚动行为 ")])])],1)],1)},dt=[],ht={methods:{handleChange:function(){}}},ft=ht,bt=Object(s["a"])(ft,ut,dt,!1,null,"3c17f954",null),gt=bt.exports,St=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"数组的解构赋值",name:"1"}},[a("p",[e._v("可以从数组中提取值，按照对应位置，对变量赋值")]),a("p",[e._v(" 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值 ")]),a("p",[e._v(" 解构赋值允许指定默认值,ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效 ")]),a("p",[e._v("如果解构不成功，变量的值就等于undefined")]),a("p",[e._v(" 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功 ")]),a("p",[e._v(" 解构赋值允许指定默认值，如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值 ")])]),a("el-collapse-item",{attrs:{title:"对象的解构赋值",name:"2"}},[a("p",[e._v(" 解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值 ")]),a("p",[e._v("对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量")]),a("p",[e._v(" 如果变量名与属性名不一致，必须写成下面这样：let { foo: baz } = { foo: 'aaa', bar: 'bbb' } ")]),a("p",[e._v(" 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者 ")]),a("p",[e._v("与数组一样，解构也可以用于嵌套结构的对象")]),a("p",[e._v("注意，对象的解构赋值可以取到继承的属性")]),a("p",[e._v(" 对象的解构也可以指定默认值，默认值生效的条件是，对象的属性值严格等于undefined ")]),a("p",[e._v("由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构")])]),a("el-collapse-item",{attrs:{title:"字符串的解构赋值",name:"3"}},[a("p",[e._v(" 字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象 ")]),a("p",[e._v(" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值：let {length : len} = 'hello' ")])]),a("el-collapse-item",{attrs:{title:"数值和布尔值的解构赋值",name:"4"}},[a("p",[e._v("解构赋值时，如果等号右边是数值和布尔值，则会先转为对象")]),a("p",[e._v(" 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错 ")])]),a("el-collapse-item",{attrs:{title:"函数参数的解构赋值",name:"5"}},[a("p",[e._v("函数参数的解构也可以使用默认值")])]),a("el-collapse-item",{attrs:{title:"圆括号问题",name:"6"}},[a("p",[e._v(" 解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 ")]),a("p",[e._v(" 以下三种解构赋值不得使用圆括号：1.变量声明语句；2.函数参数；3.赋值语句的模式 ")]),a("p",[e._v(" 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号 ")])]),a("el-collapse-item",{attrs:{title:"用途",name:"7"}},[a("p",[e._v("1.交换变量的值")]),a("p",[e._v("2.从函数返回多个值")]),a("p",[e._v("3.函数参数的定义，可以方便地将一组参数与变量名对应起来")]),a("p",[e._v("4.函数参数的默认值")]),a("p",[e._v("5.提取 JSON 数据")]),a("p",[e._v("6.遍历 Map 结构")]),a("p",[e._v("7.输入模块的指定方法")])])],1)],1)},yt=[],Ot={methods:{handleChange:function(){}}},Mt=Ot,xt=Object(s["a"])(Mt,St,yt,!1,null,"6e05a599",null),Ct=xt.exports,jt=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"模板字符串",name:"1"}},[a("p",[e._v(" 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量 ")]),a("p",[e._v(" 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中 ")]),a("p",[e._v("模板字符串中嵌入变量，需要将变量名写在${}之中")]),a("p",[e._v(" 大括号内部可以放入任意的JavaScript表达式，可以进行运算，引用对象属性,以及调用函数 ")]),a("p",[e._v("如果大括号中的值不是字符串，将按照一般的规则转为字符串")]),a("p",[e._v(" 由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出 ")]),a("p",[e._v("模板字符串甚至还能嵌套")]),a("p",[e._v("如果需要引用模板字符串本身，在需要时执行，可以写成函数")])]),a("el-collapse-item",{attrs:{title:"标签模板",name:"2"}},[a("p",[e._v(" 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数 ")]),a("p",[e._v(" 如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数 ")]),a("p",[e._v(" “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容 ")]),a("p",[e._v("标签模板的另一个应用，就是多语言转换（国际化处理）")])])],1)],1)},Et=[],Tt={methods:{handleChange:function(){}}},Nt=Tt,wt=Object(s["a"])(Nt,jt,Et,!1,null,"eaa34c70",null),kt=wt.exports,Lt=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"css实现自动水平垂直居中",name:"1"}},[a("p",[e._v(" 1.父元素display：flex;然后align-items：center;justify-contetn：center; ")]),a("p",[e._v(" 2.position：absolute;分两种：1.left：50%;height：50%;之后用margin-left或者transform要居中元素宽高一半的负值；2.left：0;right：0;top：0;bottom：0;形成自适应流元素，设定宽高之后margin：auto; ")]),a("p",[e._v(" 3.父元素display：table;子元素display：table-cell;text-align：center;verti-align：middle;孙子元素display：inline-block; ")])]),a("el-collapse-item",{attrs:{title:"meta标签",name:"2"}},[a("p",[e._v(" 提供了HTML的元数据，不会显示在客户端，但是会被浏览器解析。meta元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者以及其他元数据。 ")])]),a("el-collapse-item",{attrs:{title:"display：none、visibility：hidden和opacity：0的区别",name:"3"}},[a("p",[e._v(" visibility和opacity隐藏后依然占据空间，会被子元素继承，opacity能被transition过渡识别，其他的不行。 ")]),a("p",[e._v(" display：none 让元素隐藏，隐藏后不占空间，不会被子元素继承，不会触发事件，transition无效 ")]),a("p",[e._v(" visibility：hidden 让元素隐藏，隐藏后依然占据空间，会被子元素继承，不会触发事件，transition无效 ")]),a("p",[e._v(" opacity：0 让元素隐藏，隐藏后依然占据空间，会被子元素继承，可以触发事件，transition有效 ")])]),a("el-collapse-item",{attrs:{title:"语义化的理解",name:"4"}},[a("p",[e._v(" 1.HTML5的语义化指的是正确的使用语义化的标签来创建页面结构，所谓语义化的标签即从标签的名字可以直观的知道这个标签的作用。 ")]),a("p",[e._v(" 2.代码结构清晰，易于阅读，利于开发和维护；方便其他设备解析，根据语义渲染网页；有利于搜索引擎优化。 ")])]),a("el-collapse-item",{attrs:{title:"Doctype作用，严格模式和混杂模式如何区分以及有何意义",name:"5"}},[a("p",[e._v(" DOCTYPE位于文档中的第一行，处于html标签之前，就告知浏览器的解析器用什么文档标准进行解析。严格模式（标准模式）的排版和JS运作模式都以浏览器支持的最高标准运行；混杂模式（兼容模式或怪异模式）里页面以更宽松的向后兼容的方式显示，以防站点无法工作，当DOCTYPE不存在或格式不正确时文档会以混杂模式呈现。 ")])]),a("el-collapse-item",{attrs:{title:"如何清除浮动",name:"6"}},[a("p",[e._v("1.添加额外标签，clear：both;")]),a("p",[e._v("2.父元素overflow：hidden;")]),a("p",[e._v("3.使用before和after伪元素，clear：both")]),a("p",[e._v("4.给父元素设置高度")]),a("p",[e._v("5.让父元素也浮动")])]),a("el-collapse-item",{attrs:{title:"HTML5新特性",name:"7"}},[a("p",[e._v(" 语义化标签；增强型表单；视频与音频；canvas绘图；svg绘图；地理定位；拖放API；Web Worker；Web Storage；Websocket ")])]),a("el-collapse-item",{attrs:{title:"BFC",name:"8"}},[a("p",[e._v(" W3C对BFC的定义：浮动元素和绝对定位元素，非块级盒子的块级容器，以及overflow不为visible。 ")])]),a("el-collapse-item",{attrs:{title:"Canvas和SVG有什么区别",name:"9"}},[a("p",[e._v(" svg缩放不影响显示,svg对象的属性发生变化，那么浏览器能够自动重现图形。canvas中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象 ")]),a("p",[e._v(" svg不依赖分辨率，支持事件处理器，最适合带有大型渲染区域的应用程序（比如谷歌地图），复杂度高会减慢渲染速度（任何过度使用DOM的应用都不快） ")]),a("p",[e._v(" canvas依赖分辨率，不支持事件处理器，弱的文本渲染能力，能够以.png或.jpg格式保存结果图像，最适合图像密集型的游戏，其中的许多对象会被频繁重绘 ")])]),a("el-collapse-item",{attrs:{title:"FOUC",name:"10"}},[a("p",[e._v("FOUC：文档样式短暂失效(Flash of Unstyled Content)")]),a("p",[e._v(" 造成原因：使用import导入样式表，当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。当样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。 ")]),a("p",[e._v("解决办法：使用link标签引入样式表")])]),a("el-collapse-item",{attrs:{title:"为什么要初始化css样式",name:"11"}},[a("p",[e._v(" 不同的浏览器对有些标签的默认值是不同的，初始化CSS能避免因为浏览器的不同使得页面显示差异，而且也有助于之后页面排版和书写 ")])]),a("el-collapse-item",{attrs:{title:"媒体查询",name:"12"}},[a("p",[e._v(" 使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。 ")]),a("p",[e._v(' css语法： @media mediatype and|not|only (media feature) { CSS-Code; } 或者你也可以针对不同的媒体使用不同stylesheets： <link rel="stylesheet" media="mediatype and|not|only (media feature)" href="mystylesheet.css"> ')])])],1)],1)},Dt=[],Pt={methods:{handleChange:function(){}}},Rt=Pt,Jt=Object(s["a"])(Rt,Lt,Dt,!1,null,"13376dde",null),At=Jt.exports,It=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"null和undefine的区别",name:"1"}},[a("p",[e._v("null表示没有对象，即此处不应该有值")]),a("p",[e._v("undefine表示声明了但未赋值，即此处应该有值，但没有定义")])]),a("el-collapse-item",{attrs:{title:"JS如何进行继承",name:"2"}},[a("p",[e._v("原型链、构造函数、组合式、原型式、寄生式、组合寄生式")])]),a("el-collapse-item",{attrs:{title:"new操作符做了哪些事",name:"3"}},[a("p",[e._v(" 创建一个空对象，设置原型链，让实例的this指向obj，并执行Func的函数体，判断实例的返回值类型 ")])]),a("el-collapse-item",{attrs:{title:"闭包",name:"4"}},[a("p",[e._v(" 闭包就是函数，但是它可以继承并访问它自身被被声明的那个作用域里的变量。 ")]),a("p",[e._v("优点：逻辑连续、方便调用上下文的局部变量，加强封装性。")]),a("p",[e._v("缺点：容易造成内存浪费。")])]),a("el-collapse-item",{attrs:{title:"JS的垃圾回收机制",name:"5"}},[a("p",[e._v("标记清除、引用计数")])]),a("el-collapse-item",{attrs:{title:"cookie的利弊以及和web storage的区别",name:"6"}},[a("p",[e._v(" cookie优点：不需要任何服务器资源，数据简单，基于文档的轻量结构，可配置生命周期。 ")]),a("p",[e._v(" cookie缺点：数量和长度都有限制，有安全风险，可能被用户禁用，有些状态不可能保存在客户端。 ")]),a("p",[e._v(" 区别：存储空间不同；能否与服务器交互；API接口设置不同；能否跨域（cookie不能跨域）。 ")])]),a("el-collapse-item",{attrs:{title:"bind()、apply()和call()的异同",name:"7"}},[a("p",[e._v("同：改变当前作用域中的this指向")]),a("p",[e._v(" 异：bind()用于方法，其他的用于函数，apply()和call()第一个参数都是新的this指向，而且可以传更多参数，apply()只需要传入一个所需参数的数组 ，call()则需要一个一个的传入。 ")])]),a("el-collapse-item",{attrs:{title:"关于Ajax以及Ajax的请求过程",name:"8"}},[a("p",[e._v(" Ajax是js、xml、css、dom等多种技术的组合应用，用来实现客户端的异步操作，在不刷新页面的情况下和服务器进行通信，支持更新部分页面而不重载页面，减少用户的等待时间。 ")]),a("p",[e._v(" 创建XMLHttpRequest对象、创建一个新的HTTP请求，并指定请求方式，URL以及验证信息、设置响应HTTP请求状态变化的函数、发送请求、获取异步调用返回的数据、实现页面刷新。 ")])]),a("el-collapse-item",{attrs:{title:"JSON",name:"9"}},[a("p",[e._v(" 一种轻量级的数据交换格式，易于阅读和书写，采用完全独立于程序语言的文本格式，也使用了类C语言的习惯，使得JSON成为理想的数据交换语言。 ")])]),a("el-collapse-item",{attrs:{title:"深浅拷贝",name:"10"}},[a("p",[e._v("1.递归直接复制引用对象的键值对")]),a("p",[e._v("2.使用JSON对象的stringify和parse方法")])]),a("el-collapse-item",{attrs:{title:"怎么判断一个对象是否是空的",name:"11"}},[a("p",[e._v("1.使用JSON.stringify将对象转为JSON字符串，再和'{}'比较")]),a("p",[e._v("2.使用Object.getOwnPropertyNames(),判断返回的数组长度是否为0")]),a("p",[e._v("3.使用Object.keys()或Object.values()，判断返回的数组长度是否为0")])]),a("el-collapse-item",{attrs:{title:"如何实现前端路由",name:"12"}},[a("p",[e._v(" 要实现前端路由，需要解决两个核心问题：1.如何改变URL却不引起页面刷新；2.如何检测URL变化了 ")]),a("p",[e._v(" hash实现：hash是URL中hash以及后面的部分，改变URL中的hash部分不会引起页面刷新；通过hashchange()事件监听URL的变化，改变URL的方式只有这几种：通过浏览器前进后退改变URL、通过a标签改变URL、通过window.location改变URL，这几种情况改变URL都会触发hashchange事件 ")]),a("p",[e._v(" history实现：history提供了pushState和replaceState两个方法，这两个方法改变URL的path部分不会引起页面刷新；history提供类似hashchange的popstate事件，通过浏览器前进后退改变URL时会触发popstate事件，但是通过pushState/replaceState或a标签改变URL不会触发popstate事件， 我们可以通过拦截pushState/replaceState的调用和a标签的点击事件来检测URL变化。 ")])]),a("el-collapse-item",{attrs:{title:"类的实现和继承原理",name:"13"}},[a("p",[e._v(" 类的实现：调用_classCallCheck方法判断当前函数调用前是否有new关键字；将class内部的变量和函数赋给this；执行constuctor内部的逻辑；return this。 ")]),a("p",[e._v(" 继承的实现：调用_inherits函数继承父类的proptype；用一个闭包保存父类引用，在闭包内部做子类构造逻辑；new检查；用当前this调用父类构造函数；将子类class内部的变量和函数赋给this；执行子类constuctor内部的逻辑 ")])]),a("el-collapse-item",{attrs:{title:"函数节流和函数防抖",name:"14"}},[a("p",[e._v(" 函数节流的要点是：声明一个变量当标志位，记录当前代码是否在执行，如果空闲，则可以正常触发方法执行，如果代码在执行中，则取消这次执行，直接return。函数节流不是避免执行方法，而是调用方法后会进行一次判断，满足条件才能执行，通常会给真正的方法体设置定时器，让其在固定事件内只执行一次。 ")]),a("p",[e._v(" 函数防抖的要点是：延迟执行需要跑的代码，如果方法多次触发，则不断的清除定时器，重新开始计时，如果计时完毕，期间没有触发方法，则正常执行代码。 ")])]),a("el-collapse-item",{attrs:{title:"对模块化的理解",name:"15"}},[a("p",[e._v(" 封装细节，提供使用接口，彼此之间互不影响，每个模块都实现某一特定的功能。好处是可以避免变量污染，命名冲突，提高代码复用性，更好维护和管理。 ")])]),a("el-collapse-item",{attrs:{title:"哪些操作会引起内存泄漏",name:"16"}},[a("p",[e._v(" 意外的全局变量；闭包；没有清理的DOM元素引用；被遗忘的定时器或回调；子元素存在引用。 ")])]),a("el-collapse-item",{attrs:{title:"如何看待webpack",name:"17"}},[a("p",[e._v(" WebPack 是一个模块打包工具，可以使用WebPack管理模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Js、CSS以及各种静态文件，让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后生成优化且合并后的静态资源。 ")])]),a("el-collapse-item",{attrs:{title:"定义对象的方法",name:"18"}},[a("p",[e._v("直接创建；实例化构造函数；Object.create()")])]),a("el-collapse-item",{attrs:{title:"对promise的理解",name:"19"}},[a("p",[e._v(" ES6将promise写进了语言标准，原生提供了promise对象，ES6规定，pormise对象是一个构造函数，用来生成promise实例。promise是用来解决异步处理回调金字塔问题的。 ")]),a("p",[e._v(" 特点：promise对象的状态只跟异步操作的结果有关，不受外界影响；promise的状态一旦改变，就不会再变，是不可逆的 ")]),a("p",[e._v(" 缺点：无法取消，一旦创建就会立即执行；如果不设置回调函数，promise内部抛出的错误，不会反映到外部；当处于pending状态的时候，无法得知目前进展到了哪个阶段，是刚刚开始还是即将完成。 ")])]),a("el-collapse-item",{attrs:{title:"对AMD、CMD和CommonJs的理解",name:"20"}},[a("p",[e._v(" AMD/CMD/CommonJs是JS模块化开发的标准，目前对应的实现是RequireJs/SeaJs/nodeJs ")]),a("p",[e._v("CommonJs主要针对服务端，AMD/CMD主要针对浏览器端")]),a("p",[e._v(" AMD是预加载，在并行加载js文件同时，还会解析执行该模块；CMD是懒加载，并行加载js文件，在需要的时候才会执行 ")]),a("p",[e._v("AMD优缺点：加载速度快，但是JS文件执行的顺序不可控")]),a("p",[e._v("CMD优缺点：JS文件执行顺序可控，但是由于是同步执行，执行时间会叠加")])]),a("el-collapse-item",{attrs:{title:"web开发中的会话跟踪",name:"21"}},[a("p",[e._v("cookie；session；隐藏表单域；URL重写；IP地址")])]),a("el-collapse-item",{attrs:{title:"关于eval",name:"22"}},[a("p",[e._v("功能：把字符串解析成js代码执行并返回结果")]),a("p",[e._v("作用域：会把当前eval的作用域赋值过去")]),a("p",[e._v("注意：应该避免使用eval，不安全，耗性能")]),a("p",[e._v("应用：可以把json字符串转为json对象")])]),a("el-collapse-item",{attrs:{title:"Js延迟加载",name:"23"}},[a("p",[e._v("defer；async；动态创建脚本；定时器延迟执行方法；把脚本放到底部")])]),a("el-collapse-item",{attrs:{title:"渐进增强和优雅降级",name:"24"}},[a("p",[e._v(" 渐进增强：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验 ")]),a("p",[e._v("优雅降级：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容")]),a("p",[e._v(" 区别：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的、能够起作用的版本开始，并不断扩充，以适应未来环境的需要 ")])]),a("el-collapse-item",{attrs:{title:"attribute和property的区别",name:"25"}},[a("p",[e._v(" property是DOM中的属性，是JavaScript里的对象；attribute是HTML标签上的特性，它的值只能是字符串。某种意义上property包含了attribute。 ")])]),a("el-collapse-item",{attrs:{title:"为什么操作DOM慢",name:"26"}},[a("p",[e._v(" DOM本身是一个js对象, 操作这个对象本身不慢, 但是操作后触发了浏览器的行为, 如repaint和reflow等浏览器行为, 使其变慢 ")])]),a("el-collapse-item",{attrs:{title:"CSRF和XSS区别和预防",name:"27"}},[a("p",[e._v(" CSRF（Cross-site request forgery）跨站请求伪造：假设你登陆了a网站，此时你又打开了b网站的某个页面，b网站的某个页面上有一段代码，可能是一个自提交的表单，表单的action是a网站，这样b网站就模拟了你的身份，向a网站发送了一个请求。CSRF的攻击特点是伪造其他网站的操作，冒用身份比如利用cookie伪造登录凭证，不是窃取cookie。 ")]),a("p",[e._v(" 解决方案：对于跨站请求伪造，最重要的就是区分访问源头。因为发生在其他人的网站，防止攻击来源的产生是不可能的，只能从提升自己网站的甄别度来解决。1.有每一个表单都带有一个CSRF令牌（CSRF TOKEN）,后端验证没有令牌的直接被拒绝，这里的令牌需要和会话绑定更能确保安全性，尤其是不要提供获取CSRF令牌的接口，否则就形同虚设了；2.验证HTTP Referer字段；3.验证码（现在基本大型网站重要的操作都会进行验证，甚至是手机验证码验证来保障安全） ")]),a("p",[e._v(" XSS （Cross-site scripting）跨站脚本攻击，这里缩写css被前端层叠样式表（Cascading Style Sheets）占用了，为了区分就叫了xss。属于注入攻击的一种。窃取用户cookie，损害/控制用户电脑做出某些行为，模拟用户操作等。xss的攻击如果成功，一般来说是可以造成很严重后果的，因为对方相当于直接控制了你的操作，并做出一些你自己不会做的事情，CSRF相对来说，只是模拟了操作，还是受到服务提供者限制的。 ")]),a("p",[e._v(" 解决方案：网站不应该信任用户输入的内容，应对用户输入内容进行处理，过滤任何有执行能力的脚本或者影响页面的CSS，保证其他用户访问页面的安全。具体针对每种语言都有相应的处理机制和工具。一般各种后端框架都封装或者提供相关插件处理。 ")])])],1)],1)},Ht=[],$t={methods:{handleChange:function(){}}},Ut=$t,Ft=Object(s["a"])(Ut,It,Ht,!1,null,"2317167c",null),Vt=Ft.exports,Wt=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"响应式原理",name:"1"}},[a("p",[e._v(" 当你把一个普通的JavaScript对象传入Vue实例作为data选项，Vue将遍历此对象所有的property，并使用Object.defineProperty把这些property全部转为getter/setter。Object.defineProperty是ES5中一个无法shim的特性，这也就是Vue不支持IE8以及更低版本浏览器的原因 ")]),a("p",[e._v(" Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue刷新队列并执行实际(已去重的)工作。Vue在内部对异步队列尝试使用原生的Promise.then、MutationObserver和setImmediate，如果执行环境不支持，则会采用setTimeout(fn, 0)代替。 ")]),a("p",[e._v(" 虽然Vue.js通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触DOM，但是有时我们必须要这么做。为了在数据变化之后等待Vue完成更新DOM，可以在数据变化之后立即使用Vue.nextTick(callback)。这样回调函数将在DOM更新完成后被调用 ")])]),a("el-collapse-item",{attrs:{title:"父子组件间通信方式",name:"2"}},[a("p",[e._v("props：父向子传值")]),a("p",[e._v("$emit：子向父传值")]),a("p",[e._v("provide和inject：祖先向子孙传值")]),a("p",[e._v(" $parent和$children：利用$children可以直接获取子组件的实例，利用$parent则可以直接获取到父组件的实例 ")]),a("p",[e._v("VueX")]),a("p",[e._v(" Bus总线：中央事件总线的方式。新建一个Vue事件bus对象，然后通过bus.$emit触发事件，bus.$on监听触发的事件。 ")])]),a("el-collapse-item",{attrs:{title:"路由懒加载",name:"3"}},[a("p",[e._v(" 像vue这种单页面应用，如果没有应用懒加载，运用webpack打包后的文件将会异常的大，造成进入首页时，需要加载的内容过多，时间过长，会出现长时间的白屏，即使做了loading也是不利于用户体验，而运用懒加载则可以将页面进行划分，需要的时候才加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时 ")])]),a("el-collapse-item",{attrs:{title:"虚拟DOM",name:"4"}},[a("p",[e._v(" 用我们传统的开发模式，原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。例如，第一次计算完，紧接着下一个DOM更新请求，这个节点的坐标值就变了，前一次计算为无用功。计算DOM节点坐标值等都是白白浪费的性能。即使计算机硬件一直在迭代更新，操作DOM的代价仍旧是昂贵的，频繁操作还是会出现页面卡顿，影响用户体验。 ")]),a("p",[e._v(" 虚拟DOM就是为了解决浏览器性能问题而被设计出来的。如前，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。所以，用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。 ")])]),a("el-collapse-item",{attrs:{title:"vue的SEO问题",name:"5"}},[a("p",[e._v(" seo关系到网站排名, vue搭建spa做前后端分离不好做seo，可通过其他方法解决：1.SSR服务端渲染: 将同一个组件渲染为服务器端的HTML字符串，利于seo且更快；2.vue-meta-info，nuxt，prerender-spa-plugin页面预渲染等 ")])]),a("el-collapse-item",{attrs:{title:"create和mounted的区别",name:"6"}},[a("p",[e._v(" created: 在模板渲染成html前调用，即通常初始化某些数据，然后再渲染成视图。mounted: 在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作和方法。 ")])])],1)],1)},qt=[],Bt={methods:{handleChange:function(){}}},Gt=Bt,Yt=Object(s["a"])(Gt,Wt,qt,!1,null,"20853733",null),Xt=Yt.exports,zt=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"前端跨域问题",name:"1"}},[a("p",[e._v("JSONP：只能实现get请求")]),a("p",[e._v("document.domain + iframe：仅限主域相同，子域不同的跨域应用场景")]),a("p",[e._v("location.hash + iframe：不同域之间利用iframe的location.hash传值")]),a("p",[e._v(" window.name + iframe：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传到本地域。 ")]),a("p",[e._v(" postMessage：HTML5 XMLHttpRequest Level 2中的API，是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：页面和其打开的新窗口的数据传递；多窗口之间消息传递 ；页面与嵌套的iframe消息传递；上面三个场景的跨域数据传递 ")]),a("p",[e._v(" 跨域资源共享(cors)：普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置；带cookie请求：前后端都需要设置 ")]),a("p",[e._v("nginx代理跨域")]),a("p",[e._v("Nodejs中间件代理跨域")]),a("p",[e._v("WebSocket协议跨域")])]),a("el-collapse-item",{attrs:{title:"HTTP请求方法",name:"2"}},[a("p",[e._v("GET：请求指定的页面信息，并返回实体主体。")]),a("p",[e._v(" HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 ")]),a("p",[e._v(" POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。 ")]),a("p",[e._v("PUT：从客户端向服务器传送的数据取代指定的文档的内容。")]),a("p",[e._v("DELETE：请求服务器删除指定的数据。")]),a("p",[e._v("CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。")]),a("p",[e._v("OPTIONS：允许客户端查看服务器的性能。")]),a("p",[e._v("TRACE：回显服务器收到的请求，主要用于测试或诊断。")])]),a("el-collapse-item",{attrs:{title:"GET和POST的区别",name:"3"}},[a("p",[e._v(" POST比GET更安全，参数不会被保存在浏览器历史或web服务器中，GET发送的数据是URL的一部分，对所有人可见，而POST的数据不会显示在URL中。 ")])]),a("el-collapse-item",{attrs:{title:"从输入URL到页面加载的过程",name:"4"}},[a("p",[e._v(" 浏览器构建HTTP Request请求：1.应用层进行DNS解析；2.应用层生成HTTP请求报文；3.传输层建立TCP连接；4.网络层使用IP协议来选择路线；5.数据链路层实现网络相邻结点间可靠的数据通信；6.物理层传输数据 ")]),a("p",[e._v(" 网络传输：从客户机到服务器需要通过许多网络设备，一般地，包括集线器、交换器、路由器等 ")]),a("p",[e._v("服务器处理及反向传输")]),a("p",[e._v(" 浏览器渲染：1.如果HTTP响应报文是301或302重定向，则浏览器会相应头中的location再次发送请求；2.浏览器处理HTTP响应报文中的主体内容，首先使用loader模块加载相应的资源；3.使用parse模块解析HTML、CSS、Javascript资源；4.构建Render树及RenderLayer树；5.布局和渲染；6.硬件加速。 ")])])],1)],1)},Kt=[],Qt={methods:{handleChange:function(){}}},Zt=Qt,ea=Object(s["a"])(Zt,zt,Kt,!1,null,"9e1a2850",null),ta=ea.exports,aa=function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("div",[a("el-collapse",{attrs:{accordion:""},on:{change:e.handleChange}},[a("el-collapse-item",{attrs:{title:"对浏览器内核的理解",name:"1"}},[a("p",[e._v(" 浏览器最重要或者说核心的部分是“Rendering Engine”，可大概译为“渲染引擎”，不过我们一般习惯将之称为“浏览器内核”。负责对网页语法的解释并渲染网页。所以，通常所谓的浏览器内核也就是浏览器所采用的渲染引擎，渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。不同的浏览器内核对网页编写语法的解释也有不同，因此同一网页在不同的内核的浏览器里的渲染效果也可能不同，这也是网页编写者需要在不同内核的浏览器中测试网页显示效果的原因 ")])]),a("el-collapse-item",{attrs:{title:"HTML5的离线储存怎么使用，解释工作原理",name:"2"}},[a("p",[e._v(" 原理：HTML5的离线存储是基于一个新建的.appcache文件的，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 ")]),a("p",[e._v(' 使用方法：首先，在html页面头部加入一个manifest的属性：<html manifest="cache.manifest"></html>;然后书写cache.manifest文件。 ')])]),a("el-collapse-item",{attrs:{title:"前端性能优化",name:"3"}},[a("p",[e._v(" 减少http请求，合理设置HTTP缓存：http协议是无状态的应用层协议，意味着每次http请求都需要建立通信链路、进行数据传输，而在服务器端，每个http都需要启动独立的线程去处理。这些通信和服务的开销都很昂贵，减少http请求的数目可有效提高访问性能；怎样设置缓存才算合理设置?原则很简单，能缓存越多越好，能缓存越久越好。 ")]),a("p",[e._v(" 使用浏览器缓存：对一个网站而言，CSS、javascript、logo、图标这些静态资源文件更新的频率都比较低，而这些文件又几乎是每次http请求都需要的，如果将这些文件缓存在浏览器中，可以极好的改善性能。通过设置http头中的cache-control和expires的属性，可设定浏览器缓存，缓存时间可以是数天，甚至是几个月。 ")]),a("p",[e._v(" 启用压缩：在服务器端对文件进行压缩，在浏览器端对文件解压缩，可有效减少通信传输的数据量 ")]),a("p",[e._v("CSS Sprites：合并CSS图片")]),a("p",[e._v("图片懒加载")]),a("p",[e._v("减少cookie传输")]),a("p",[e._v(" 使用CDN加速：CDN（content distribute network，内容分发网络）的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快速度获取数据。 ")]),a("p",[e._v("反向代理")])]),a("el-collapse-item",{attrs:{title:"前端SEO",name:"4"}},[a("p",[e._v(" 网站结构布局优化：1.控制首页链接数量；2.扁平化的目录层次，尽量不超过三层；3.导航优化；4.网站的结构布局，包括头部、主体、底部；5.控制页面的大小，减少http请求，提高网站的加载速度。 ")]),a("p",[e._v(' 网页代码优化：1.<title>标题：只强调重点即可，尽量把重要的关键词放在前面，关键词不要重复出现，尽量做到每个页面的<title>标题中不要设置相同的内容；2.<meta keywords>标签：列举出几个页面的重要关键字即可，切记过分堆砌；3.<meta description>标签：需要高度概括网页内容；4.<body>中的标签：尽量让代码语义化，在适当的位置使用适当的标签，用正确的标签做正确的事；5.<a>标签：要加“title”属性加以说明，链接到其他网站的外部链接，需要加上el="nofollow"属性；6.正文标题尽量使用<h1>标签；7.<img>应该使用‘alt’属性加以说明；8.利用CSS布局，将重要内容的HTML代码放在最前面；9.尽量少使用iframe框架。 ')])]),a("el-collapse-item",{attrs:{title:"Ts的优缺点",name:"5"}},[a("p",[e._v(" TypeScript增加了代码的可读性和可维护性：类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了；可以在编译阶段就发现大部分错误，这总比在运行时候出错好；增强了编辑器和IDE的功能，包括代码补全、接口提示、跳转到定义、重构等。 ")]),a("p",[e._v(" TypeScript非常包容：即使不显式的定义类型，也能够自动做出[类型推论]()；可以定义从简单到复杂的几乎一切类型；即使TypeScript编译报错，也可以生成JavaScript文件；兼容第三方库，即使第三方库不是用TypeScript写的，也可以编写单独的类型文件供TypeScript读取。 ")]),a("p",[e._v(" TypeScript拥有活跃的社区：大部分第三方库都有提供给TypeScript的类型定义文件；Google 开发的Angular2就是使用TypeScript编写的；TypeScript拥抱了ES6规范，也支持部分ESNext草案的规范。 ")]),a("p",[e._v(" TypeScript的缺点：有一定的学习成本，需要理解接口（Interfaces）、泛型（Generics）、类（Classes）、枚举类型（Enums）等前端工程师可能不是很熟悉的概念；短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript能够减少其维护成本；集成到构建流程需要一些工作量；可能和一些库结合的不是很完美。 ")])])],1)],1)},na=[],la={methods:{handleChange:function(){}}},pa=la,oa=Object(s["a"])(pa,aa,na,!1,null,"431c108b",null),ia=oa.exports;n["default"].use(k["a"]);var sa=new k["a"]({routes:[{path:"/",redirect:"/firstpage"},{path:"/firstpage",component:A,redirect:"/string",children:[{path:"/string",component:V},{path:"/number",component:X},{path:"/object",component:te},{path:"/set",component:ie},{path:"/map",component:_e},{path:"/array",component:ge},{path:"/math",component:Ce},{path:"/reg",component:ke},{path:"/dom",component:Ae},{path:"/promise",component:Ve},{path:"/strict",component:Xe},{path:"/flexbox",component:tt},{path:"/webfont",component:it},{path:"/weilei",component:_t},{path:"/uncommoncss",component:gt},{path:"/templatestring",component:kt},{path:"/destruct",component:Ct},{path:"/h5css",component:At},{path:"/js",component:Vt},{path:"/vue",component:Xt},{path:"/http",component:ta},{path:"/others",component:ia}]}]}),ra=sa;a("150b");n["default"].config.productionTip=!1,n["default"].prototype.$setMainHeight=function(){var e=window.innerHeight-42,t=document.querySelector(".el-main");t.style.cssText="height: ".concat(e)+"px"},document.oncontextmenu=function(){return!1},new n["default"]({router:ra,render:function(e){return e(c)}}).$mount("#app")},d403:function(e,t,a){"use strict";a("f470")},f470:function(e,t,a){}});
//# sourceMappingURL=app.0dfe6ce2.js.map